<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LeetCode Flashcards</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <style>
    .flip-card-container {
      perspective: 1000px;
    }
    .flip-card {
      position: relative;
      width: 100%;
      height: 100%;
      transition: transform 0.6s;
      transform-style: preserve-3d;
    }
    .flip-card.flipped {
      transform: rotateY(180deg);
    }
    .flip-card-front, .flip-card-back {
      position: absolute;
      width: 100%;
      height: 100%;
      backface-visibility: hidden;
      overflow: hidden;
    }
    .flip-card-front {
      background-color: white;
      z-index: 2;
    }
    .flip-card-back {
      background-color: #2d3748;
      color: white;
      transform: rotateY(180deg);
    }
          .tab-content {
      height: calc(100% - 120px);
      overflow-y: auto;
    }
    .grid-container {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 1rem;
    }
    .flip-card-container {
      perspective: 1000px;
      width: 100%;
      max-width: 600px;
      height: 600px;
      margin: 0 auto;
    }
    .flip-card-front, .flip-card-back {
      border: 1px solid #ccc;
      min-height: 500px; /* Ensure minimum height */
    }
    /* Add scrollbar styling for code blocks */
    #code-content pre {
      max-height: 400px;
      overflow-y: auto;
      white-space: pre-wrap;
    }
  </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col">
  <header class="bg-gray-800 text-white shadow-md">
    <div class="container mx-auto py-4 px-6">
      <h1 class="text-2xl font-bold">LeetCode Flashcards</h1>
    </div>
  </header>
  <main class="flex-grow container mx-auto p-6">
    <div id="topic-section">
      <h2 class="text-xl font-semibold mb-6">Select a Topic</h2>
      <div id="topic-grid" class="grid-container"></div>
    </div>
    <div id="flashcard-section" class="hidden">
      <div class="mb-6">
        <button id="back-button" class="bg-gray-700 hover:bg-gray-600 text-white px-3 py-1 rounded">Back to Topics</button>
        <h2 id="current-topic" class="text-xl font-semibold mt-4"></h2>
        <div class="flex justify-between items-center mt-2">
          <p id="problem-counter" class="text-gray-600"></p>
          <div class="flex gap-2">
            <button id="prev-button" class="bg-gray-200 px-3 py-1 rounded disabled:opacity-50">Previous</button> <button id="next-button" class="bg-gray-200 px-3 py-1 rounded disabled:opacity-50">Next</button>
          </div>
        </div>
      </div>
      <div class="flip-card-container w-full max-w-3xl aspect-square mx-auto">
        <div id="flashcard" class="flip-card">
          <div class="flip-card-front rounded-xl shadow-lg">
            <div class="p-5 bg-blue-600 text-white flex justify-between items-center">
              <h3 id="card-title" class="font-bold text-xl"></h3><span id="card-difficulty" class="px-2 py-1 rounded-full text-xs font-semibold"></span>
            </div>
            <div class="border-b">
              <div class="flex">
                <button id="question-tab" class="px-4 py-2 border-b-2 border-blue-500 text-blue-600">Question</button> <button id="hint-tab" class="px-4 py-2 border-b-2 border-transparent">Hint</button>
              </div>
            </div>
            <div class="tab-content p-5">
              <div id="question-content" class="text-gray-700"></div>
              <div id="hint-content" class="text-gray-700 hidden"></div>
            </div>
            <div class="absolute bottom-4 left-0 right-0 text-center text-gray-500 text-sm">
              Click to flip
            </div>
          </div>
          <div class="flip-card-back rounded-xl shadow-lg">
            <div class="p-5 bg-gray-800 text-white flex justify-between items-center">
              <h3 id="card-title-back" class="font-bold text-xl"></h3>
            </div>
            <div class="border-b border-gray-600">
              <div class="flex">
                <button id="one-liner-tab" class="px-4 py-2 border-b-2 border-blue-300 text-blue-300">One-liner</button>
                <button id="three-liner-tab" class="px-4 py-2 border-b-2 border-transparent text-gray-300">3-liner</button>
                <button id="mnemonic-tab" class="px-4 py-2 border-b-2 border-transparent text-gray-300">Mnemonic</button>
                <button id="code-tab" class="px-4 py-2 border-b-2 border-transparent text-gray-300">Code</button>
              </div>
            </div>
            <div class="tab-content p-5">
              <div id="one-liner-content" class="text-white"></div>
              <div id="three-liner-content" class="text-white hidden"></div>
              <div id="mnemonic-content" class="text-white hidden"></div>
              <div id="code-content" class="hidden">
                <pre id="code-block" class="font-mono text-sm bg-gray-900 p-4 rounded text-white overflow-auto"></pre>
              </div>
            </div>
            <div class="absolute bottom-4 left-0 right-0 text-center text-gray-400 text-sm">
              Click to flip back
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>
  <footer class="bg-gray-800 text-white p-4 mt-8">
    <div class="container mx-auto text-center text-sm">
      <p>© 2025 LeetCode Flashcards - Master Algorithms & Data Structures</p>
    </div>
  </footer>
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // Topics data
      const topics = [
        { id: 'arrays', name: 'Arrays and Hashing' },
        { id: 'twopointers', name: 'Two Pointers' },
        { id: 'stack', name: 'Stack' },
        { id: 'binarysearch', name: 'Binary Search' },
        { id: 'slidingwindow', name: 'Sliding Window' },
        { id: 'linkedlist', name: 'Linked List' },
        { id: 'trees', name: 'Trees' },
        { id: 'tries', name: 'Tries' },
        { id: 'backtracking', name: 'Backtracking' },
        { id: 'heap', name: 'Heap/Priority Queue' },
        { id: 'intervals', name: 'Intervals' },
        { id: 'greedy', name: 'Greedy' },
        { id: 'advancedgraphs', name: 'Advanced Graphs' },
        { id: 'graphs', name: 'Graphs' },
        { id: 'dp1d', name: '1-D Dynamic Programming' },
        { id: 'dp2d', name: '2-D Dynamic Programming' },
        { id: 'bitmanipulation', name: 'Bit Manipulation' },
        { id: 'mathgeometry', name: 'Math & Geometry' },
      ];

      // Problems data
      const problems = {
        arrays: [
          {
            title: 'Contains Duplicate',
            difficulty: 'Easy',
            question: 'Given an integer array nums, return true if any value appears more than once in the array, otherwise return false.\n\nExample 1:\nInput: nums = [1, 2, 3, 3]\nOutput: true',
            hint: 'Think about using a data structure that allows for O(1) lookups.',
            oneLiner: 'Use a set to check if any element repeats.',
            threeLiner: 'We go through each number.\nWe keep a list of ones we\'ve already seen.\nIf a number shows up again, we know it\'s a duplicate.',
            mnemonic: '"Seen before?" → if num in seen: return True\n"Add new" → seen.add(num)\n"End clean" → return False',
            code: `class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        seen = set()
        for num in nums:
            if num in seen:
                return True
            seen.add(num)
        return False

# Time Complexity: O(n)
# Space Complexity: O(n)`
          },
          {
            title: 'Valid Anagram',
            difficulty: 'Easy',
            question: 'Given two strings s and t, return true if the two strings are anagrams of each other, otherwise return false.\n\nAn anagram is a string that contains the exact same characters as another string, but the order of the characters can be different.\n\nExample 1:\n\nInput: s = "racecar", t = "carrace"\nOutput: true',
            hint: 'Count the occurrences of each character in both strings.',
            oneLiner: 'Use counters (hashmaps) to compare character frequencies.',
            threeLiner: 'We count the letters in both words.\nIf every letter shows up the same number of times, it\'s an anagram.\nOtherwise, it\'s not.',
            mnemonic: '"Count both" → Counter(s) == Counter(t)\n"Compare maps" → for key in counts: compare values\n"Return result" → return True/False',
            code: `class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False

        count = [0] * 26
        for i in range(len(s)):
            count[ord(s[i]) - ord('a')] += 1
            count[ord(t[i]) - ord('a')] -= 1

        for val in count:
            if val != 0:
                return False
        return True

# Time complexity: O(n+m)
# Space complexity: O(1) since we have at most 26 different characters.`
          },
          {
            title: 'Two Sum',
            difficulty: 'Easy',
            question: 'Given an array of integers nums and an integer target, return the indices i and j such that nums[i] + nums[j] == target and i != j.\n\nYou may assume that every input has exactly one pair of indices i and j that satisfy the condition.\n\nReturn the answer with the smaller index first.\n\nExample 1:\n\nInput: nums = [3,4,5,6], target = 7\n\nOutput: [0,1]',
            hint: 'Use a hash map to store the indices of the elements you\'ve seen so far.',
            oneLiner: 'Store each number\'s complement in a hashmap as we loop.',
            threeLiner: 'We look for two numbers that add to a target.\nWe remember each number we see and what we need to reach the target.\nIf we find the right pair, we return their positions.',
            mnemonic: '"Check map" → if target - num in seen: return [i, seen[target - num]]\n"Store index" → seen[num] = i\n"Loop through" → for i, num in enumerate(nums):',
            code: `class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        indices = {}  # val -> index

        for i, n in enumerate(nums):
            indices[n] = i

        for i, n in enumerate(nums):
            diff = target - n
            if diff in indices and indices[diff] != i:
                return [i, indices[diff]]

# Time complexity: O(n)
# Space complexity: O(n)`
          },
          {
            title: 'Group Anagrams',
            difficulty: 'Medium',
            question: 'Given an array of strings strs, group all anagrams together into sublists. You may return the output in any order.\n\nAn anagram is a string that contains the exact same characters as another string, but the order of the characters can be different.\n\nExample 1:\n\nInput: strs = ["act","pots","tops","cat","stop","hat"]\n\nOutput: [["hat"],["act", "cat"],["stop", "pots", "tops"]]',
            hint: 'Think about what makes two strings anagrams of each other. How can you represent that property as a key in a hash map?',
            oneLiner: 'Group words using sorted letters as a key in a hashmap.',
            threeLiner: 'We sort the letters in each word.\nWords with the same letters go into the same group.\nWe collect all the groups.',
            mnemonic: '"Sort word" → key = \'\'.join(sorted(word))\n"Group by key" → anagram_map[key].append(word)\n"Return values" → return anagram_map.values()',
            code: `class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        res = defaultdict(list)
        for s in strs:
            count = [0] * 26
            for c in s:
                count[ord(c) - ord('a')] += 1
            res[tuple(count)].append(s)
        return list(res.values())

# Time complexity: O(m*n)
# Space complexity: O(m)`
          },
          {
            title: 'Top K Frequent Elements',
            difficulty: 'Medium',
            question: 'Given an integer array nums and an integer k, return the k most frequent elements within the array.\n\nThe test cases are generated such that the answer is always unique.\n\nYou may return the output in any order.\n\nExample 1:\n\nInput: nums = [1,2,2,3,3,3], k = 2\n\nOutput: [2,3]',
            hint: 'Count the frequency of each element and then find the k elements with the highest frequency.',
            oneLiner: 'Use a counter and a heap to get the top k items.',
            threeLiner: 'We count how many times each number shows up.\nWe keep the k most common ones.\nThen we return them.',
            mnemonic: '"Count frequency" → count = Counter(nums)\n"Heap select top" → heapq.nlargest(k, count.keys(), key=count.get)\n"Return result" → return result',
            code: `class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        count = {}
        freq = [[] for i in range(len(nums) + 1)]

        for num in nums:
            count[num] = 1 + count.get(num, 0)
        for num, cnt in count.items():
            freq[cnt].append(num)
        
        res = []
        for i in range(len(freq) - 1, 0, -1):
            for num in freq[i]:
                res.append(num)
                if len(res) == k:
                    return res

# Time complexity: O(n)
# Space complexity: O(n)`
          },
          {
            title: 'Encode and Decode Strings',
            difficulty: 'Medium',
            question: 'Design an algorithm to encode a list of strings to a single string. The encoded string is then decoded back to the original list of strings.\n\nPlease implement encode and decode\n\nExample 1:\n\nInput: ["neet","code","love","you"]\n\nOutput:["neet","code","love","you"]',
            hint: 'Think about how to separate the strings in a way that can be unambiguously decoded.',
            oneLiner: 'Use a length prefix or delimiter to encode, then decode safely.',
            threeLiner: 'We turn each word into a number + word combo.\nThat way we can separate them later.\nWe read the length to split them back correctly.',
            mnemonic: '"Encode with length" → s = str(len(word)) + "#" + word\n"Split by count" → length = int(s[:i]), then s[i+1:i+1+length]\n"Loop until done" → while i < len(s): decode',
            code: `class Solution:
    
    def encode(self, strs: List[str]) -> str:
        res = ""
        for s in strs:
            res += str(len(s)) + "#" + s
        return res

    def decode(self, s: str) -> List[str]:
        res = []
        i = 0
        
        while i < len(s):
            j = i
            while s[j] != '#':
                j += 1
            length = int(s[i:j])
            i = j + 1
            j = i + length
            res.append(s[i:j])
            i = j
            
        return res

# Time complexity: O(m) for each encode() and decode() function calls.
# Space complexity: O(m+n) for each encode() and decode() function calls`
          },
          {
            title: 'Product of Array Except Self',
            difficulty: 'Medium',
            question: 'Given an integer array nums, return an array output where output[i] is the product of all the elements of nums except nums[i].\n\nEach product is guaranteed to fit in a 32-bit integer.\n\nFollow-up: Could you solve it in O(n) time without using the division operation?\n\nExample 1:\n\nInput: nums = [1,2,4,6]\n\nOutput: [48,24,12,8]',
            hint: 'Try to solve this problem using two passes through the array, one from the left and one from the right.',
            oneLiner: 'Use prefix and suffix multiplications without division.',
            threeLiner: 'We find how much every number would be if we multiply all other numbers.\nFirst, we go left to right.\nThen, we go right to left and finish the math.',
            mnemonic: '"Left pass" → for i in range(n): res[i] *= prefix\n"Right pass" → for i in reversed(range(n)): res[i] *= suffix\n"Update prefixes" → prefix *= nums[i], suffix *= nums[i]',
            code: `class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        res = [1] * (len(nums))

        prefix = 1
        for i in range(len(nums)):
            res[i] = prefix
            prefix *= nums[i]
        postfix = 1
        for i in range(len(nums) - 1, -1, -1):
            res[i] *= postfix
            postfix *= nums[i]
        return res

# Time complexity: O(n)
# Space complexity: O(1) since the output array is excluded from space analysis.`
          },
          {
            title: 'Valid Sudoku',
            difficulty: 'Medium',
            question: 'You are given a 9 x 9 Sudoku board board. A Sudoku board is valid if the following rules are followed:\n\nEach row must contain the digits 1-9 without duplicates.\nEach column must contain the digits 1-9 without duplicates.\nEach of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without duplicates.\nReturn true if the Sudoku board is valid, otherwise return false\n\nNote: A board does not need to be full or be solvable to be valid.',
            hint: 'Use sets to track seen digits in each row, column, and 3x3 sub-box.',
            oneLiner: 'Use sets to check each row, column, and 3x3 box.',
            threeLiner: 'Each row, column, and box must have unique numbers.\nWe go through the board and record what we see.\nIf anything repeats in the same row, column, or box, it\'s not valid.',
            mnemonic: '"Check each cell" → for i in range(9): for j in range(9):\n"Use 3 keys" → row[i], col[j], box[i//3, j//3]\n"Add or return False" → if val in set: return False else: add',
            code: `class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        for row in range(9):
            seen = set()
            for i in range(9):
                if board[row][i] == ".": 
                    continue
                if board[row][i] in seen:
                    return False
                seen.add(board[row][i])
        
        for col in range(9):
            seen = set()
            for i in range(9):
                if board[i][col] == ".":
                    continue
                if board[i][col] in seen:
                    return False
                seen.add(board[i][col])
            
        for square in range(9):
            seen = set()
            for i in range(3):
                for j in range(3):
                    row = (square//3) * 3 + i
                    col = (square % 3) * 3 + j
                    if board[row][col] == ".":
                        continue
                    if board[row][col] in seen:
                        return False
                    seen.add(board[row][col])
        return True

# Time complexity: O(n^2)
# Space complexity: O(n^2)`
          },
          {
            title: 'Longest Consecutive Sequence',
            difficulty: 'Medium',
            question: 'Given an array of integers nums, return the length of the longest consecutive sequence of elements that can be formed.\n\nA consecutive sequence is a sequence of elements in which each element is exactly 1 greater than the previous element. The elements do not have to be consecutive in the original array.\n\nYou must write an algorithm that runs in O(n) time.\n\nExample 1:\n\nInput: nums = [2,20,4,10,3,4,5]\n\nOutput: 4',
            hint: 'Consider using a Set data structure to optimize lookups when checking for consecutive elements.',
            oneLiner: 'Use a set and expand sequences from the smallest number.',
            threeLiner: 'We put all the numbers in a quick lookup set.\nThen we start from numbers that are the beginning of a sequence.\nWe count how long each chain goes.',
            mnemonic: '"Add to set" → num_set = set(nums)\n"Start from beginning" → if num - 1 not in num_set:\n"Expand right" → while num + streak in num_set: streak += 1',
            code: `class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        numSet = set(nums)
        longest = 0

        for num in numSet:
            if (num - 1) not in numSet:
                length = 1
                while (num + length) in numSet:
                    length += 1
                longest = max(length, longest)
        return longest

# Time complexity: O(n)
# Space complexity: O(n)`
          }
        ],
