<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LeetCode Flashcards</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <style>
    .flip-card-container {
      perspective: 1000px;
    }
    .flip-card {
      position: relative;
      width: 100%;
      height: 100%;
      transition: transform 0.6s;
      transform-style: preserve-3d;
    }
    .flip-card.flipped {
      transform: rotateY(180deg);
    }
    .flip-card-front, .flip-card-back {
      position: absolute;
      width: 100%;
      height: 100%;
      backface-visibility: hidden;
      overflow: hidden;
    }
    .flip-card-front {
      background-color: white;
      z-index: 2;
    }
    .flip-card-back {
      background-color: #2d3748;
      color: white;
      transform: rotateY(180deg);
    }
          .tab-content {
      height: calc(100% - 120px);
      overflow-y: auto;
    }
    .grid-container {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 1rem;
    }
    .flip-card-container {
      perspective: 1000px;
      width: 100%;
      max-width: 600px;
      height: 600px;
      margin: 0 auto;
    }
    .flip-card-front, .flip-card-back {
      border: 1px solid #ccc;
      min-height: 500px; /* Ensure minimum height */
    }
    /* Add scrollbar styling for code blocks */
    #code-content pre {
      max-height: 400px;
      overflow-y: auto;
      white-space: pre-wrap;
    }
  </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col">
  <header class="bg-gray-800 text-white shadow-md">
    <div class="container mx-auto py-4 px-6">
      <h1 class="text-2xl font-bold">LeetCode Flashcards</h1>
    </div>
  </header>
  <main class="flex-grow container mx-auto p-6">
    <div id="topic-section">
      <h2 class="text-xl font-semibold mb-6">Select a Topic</h2>
      <div id="topic-grid" class="grid-container"></div>
    </div>
    <div id="flashcard-section" class="hidden">
      <div class="mb-6">
        <button id="back-button" class="bg-gray-700 hover:bg-gray-600 text-white px-3 py-1 rounded">Back to Topics</button>
        <h2 id="current-topic" class="text-xl font-semibold mt-4"></h2>
        <div class="flex justify-between items-center mt-2">
          <p id="problem-counter" class="text-gray-600"></p>
          <div class="flex gap-2">
            <button id="prev-button" class="bg-gray-200 px-3 py-1 rounded disabled:opacity-50">Previous</button> <button id="next-button" class="bg-gray-200 px-3 py-1 rounded disabled:opacity-50">Next</button>
          </div>
        </div>
      </div>
      <div class="flip-card-container w-full max-w-3xl aspect-square mx-auto">
        <div id="flashcard" class="flip-card">
          <div class="flip-card-front rounded-xl shadow-lg">
            <div class="p-5 bg-blue-600 text-white flex justify-between items-center">
              <h3 id="card-title" class="font-bold text-xl"></h3><span id="card-difficulty" class="px-2 py-1 rounded-full text-xs font-semibold"></span>
            </div>
            <div class="border-b">
              <div class="flex">
                <button id="question-tab" class="px-4 py-2 border-b-2 border-blue-500 text-blue-600">Question</button> <button id="hint-tab" class="px-4 py-2 border-b-2 border-transparent">Hint</button>
              </div>
            </div>
            <div class="tab-content p-5">
              <div id="question-content" class="text-gray-700"></div>
              <div id="hint-content" class="text-gray-700 hidden"></div>
            </div>
            <div class="absolute bottom-4 left-0 right-0 text-center text-gray-500 text-sm">
              Click to flip
            </div>
          </div>
          <div class="flip-card-back rounded-xl shadow-lg">
            <div class="p-5 bg-gray-800 text-white flex justify-between items-center">
              <h3 id="card-title-back" class="font-bold text-xl"></h3>
            </div>
            <div class="border-b border-gray-600">
              <div class="flex">
                <button id="one-liner-tab" class="px-4 py-2 border-b-2 border-blue-300 text-blue-300">One-liner</button>
                <button id="three-liner-tab" class="px-4 py-2 border-b-2 border-transparent text-gray-300">3-liner</button>
                <button id="mnemonic-tab" class="px-4 py-2 border-b-2 border-transparent text-gray-300">Mnemonic</button>
                <button id="code-tab" class="px-4 py-2 border-b-2 border-transparent text-gray-300">Code</button>
              </div>
            </div>
            <div class="tab-content p-5">
              <div id="one-liner-content" class="text-white"></div>
              <div id="three-liner-content" class="text-white hidden"></div>
              <div id="mnemonic-content" class="text-white hidden"></div>
              <div id="code-content" class="hidden">
                <pre id="code-block" class="font-mono text-sm bg-gray-900 p-4 rounded text-white overflow-auto"></pre>
              </div>
            </div>
            <div class="absolute bottom-4 left-0 right-0 text-center text-gray-400 text-sm">
              Click to flip back
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>
  <footer class="bg-gray-800 text-white p-4 mt-8">
    <div class="container mx-auto text-center text-sm">
      <p>© 2025 LeetCode Flashcards - Master Algorithms & Data Structures</p>
    </div>
  </footer>
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // Topics data
      const topics = [
        { id: 'arrays', name: 'Arrays and Hashing' },
        { id: 'twopointers', name: 'Two Pointers' },
        { id: 'stack', name: 'Stack' },
        { id: 'binarysearch', name: 'Binary Search' },
        { id: 'slidingwindow', name: 'Sliding Window' },
        { id: 'linkedlist', name: 'Linked List' },
        { id: 'trees', name: 'Trees' },
        { id: 'tries', name: 'Tries' },
        { id: 'backtracking', name: 'Backtracking' },
        { id: 'heap', name: 'Heap/Priority Queue' },
        { id: 'intervals', name: 'Intervals' },
        { id: 'greedy', name: 'Greedy' },
        { id: 'advancedgraphs', name: 'Advanced Graphs' },
        { id: 'graphs', name: 'Graphs' },
        { id: 'dp1d', name: '1-D Dynamic Programming' },
        { id: 'dp2d', name: '2-D Dynamic Programming' },
        { id: 'bitmanipulation', name: 'Bit Manipulation' },
        { id: 'mathgeometry', name: 'Math & Geometry' },
      ];

      // Problems data
      const problems = {
        arrays: [
          {
            title: 'Contains Duplicate',
            difficulty: 'Easy',
            question: 'Given an integer array nums, return true if any value appears more than once in the array, otherwise return false.\n\nExample 1:\nInput: nums = [1, 2, 3, 3]\nOutput: true',
            hint: 'Think about using a data structure that allows for O(1) lookups.',
            oneLiner: 'Use a set to check if any element repeats.',
            threeLiner: 'We go through each number.\nWe keep a list of ones we\'ve already seen.\nIf a number shows up again, we know it\'s a duplicate.',
            mnemonic: '"Seen before?" → if num in seen: return True\n"Add new" → seen.add(num)\n"End clean" → return False',
            code: `class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        seen = set()
        for num in nums:
            if num in seen:
                return True
            seen.add(num)
        return False

# Time Complexity: O(n)
# Space Complexity: O(n)`
          },
          {
            title: 'Valid Anagram',
            difficulty: 'Easy',
            question: 'Given two strings s and t, return true if the two strings are anagrams of each other, otherwise return false.\n\nAn anagram is a string that contains the exact same characters as another string, but the order of the characters can be different.\n\nExample 1:\n\nInput: s = "racecar", t = "carrace"\nOutput: true',
            hint: 'Count the occurrences of each character in both strings.',
            oneLiner: 'Use counters (hashmaps) to compare character frequencies.',
            threeLiner: 'We count the letters in both words.\nIf every letter shows up the same number of times, it\'s an anagram.\nOtherwise, it\'s not.',
            mnemonic: '"Count both" → Counter(s) == Counter(t)\n"Compare maps" → for key in counts: compare values\n"Return result" → return True/False',
            code: `class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False

        count = [0] * 26
        for i in range(len(s)):
            count[ord(s[i]) - ord('a')] += 1
            count[ord(t[i]) - ord('a')] -= 1

        for val in count:
            if val != 0:
                return False
        return True

# Time complexity: O(n+m)
# Space complexity: O(1) since we have at most 26 different characters.`
          },
          {
            title: 'Two Sum',
            difficulty: 'Easy',
            question: 'Given an array of integers nums and an integer target, return the indices i and j such that nums[i] + nums[j] == target and i != j.\n\nYou may assume that every input has exactly one pair of indices i and j that satisfy the condition.\n\nReturn the answer with the smaller index first.\n\nExample 1:\n\nInput: nums = [3,4,5,6], target = 7\n\nOutput: [0,1]',
            hint: 'Use a hash map to store the indices of the elements you\'ve seen so far.',
            oneLiner: 'Store each number\'s complement in a hashmap as we loop.',
            threeLiner: 'We look for two numbers that add to a target.\nWe remember each number we see and what we need to reach the target.\nIf we find the right pair, we return their positions.',
            mnemonic: '"Check map" → if target - num in seen: return [i, seen[target - num]]\n"Store index" → seen[num] = i\n"Loop through" → for i, num in enumerate(nums):',
            code: `class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        indices = {}  # val -> index

        for i, n in enumerate(nums):
            indices[n] = i

        for i, n in enumerate(nums):
            diff = target - n
            if diff in indices and indices[diff] != i:
                return [i, indices[diff]]

# Time complexity: O(n)
# Space complexity: O(n)`
          },
          {
            title: 'Group Anagrams',
            difficulty: 'Medium',
            question: 'Given an array of strings strs, group all anagrams together into sublists. You may return the output in any order.\n\nAn anagram is a string that contains the exact same characters as another string, but the order of the characters can be different.\n\nExample 1:\n\nInput: strs = ["act","pots","tops","cat","stop","hat"]\n\nOutput: [["hat"],["act", "cat"],["stop", "pots", "tops"]]',
            hint: 'Think about what makes two strings anagrams of each other. How can you represent that property as a key in a hash map?',
            oneLiner: 'Group words using sorted letters as a key in a hashmap.',
            threeLiner: 'We sort the letters in each word.\nWords with the same letters go into the same group.\nWe collect all the groups.',
            mnemonic: '"Sort word" → key = \'\'.join(sorted(word))\n"Group by key" → anagram_map[key].append(word)\n"Return values" → return anagram_map.values()',
            code: `class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        res = defaultdict(list)
        for s in strs:
            count = [0] * 26
            for c in s:
                count[ord(c) - ord('a')] += 1
            res[tuple(count)].append(s)
        return list(res.values())

# Time complexity: O(m*n)
# Space complexity: O(m)`
          },
          {
            title: 'Top K Frequent Elements',
            difficulty: 'Medium',
            question: 'Given an integer array nums and an integer k, return the k most frequent elements within the array.\n\nThe test cases are generated such that the answer is always unique.\n\nYou may return the output in any order.\n\nExample 1:\n\nInput: nums = [1,2,2,3,3,3], k = 2\n\nOutput: [2,3]',
            hint: 'Count the frequency of each element and then find the k elements with the highest frequency.',
            oneLiner: 'Use a counter and a heap to get the top k items.',
            threeLiner: 'We count how many times each number shows up.\nWe keep the k most common ones.\nThen we return them.',
            mnemonic: '"Count frequency" → count = Counter(nums)\n"Heap select top" → heapq.nlargest(k, count.keys(), key=count.get)\n"Return result" → return result',
            code: `class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        count = {}
        freq = [[] for i in range(len(nums) + 1)]

        for num in nums:
            count[num] = 1 + count.get(num, 0)
        for num, cnt in count.items():
            freq[cnt].append(num)
        
        res = []
        for i in range(len(freq) - 1, 0, -1):
            for num in freq[i]:
                res.append(num)
                if len(res) == k:
                    return res

# Time complexity: O(n)
# Space complexity: O(n)`
          },
          {
            title: 'Encode and Decode Strings',
            difficulty: 'Medium',
            question: 'Design an algorithm to encode a list of strings to a single string. The encoded string is then decoded back to the original list of strings.\n\nPlease implement encode and decode\n\nExample 1:\n\nInput: ["neet","code","love","you"]\n\nOutput:["neet","code","love","you"]',
            hint: 'Think about how to separate the strings in a way that can be unambiguously decoded.',
            oneLiner: 'Use a length prefix or delimiter to encode, then decode safely.',
            threeLiner: 'We turn each word into a number + word combo.\nThat way we can separate them later.\nWe read the length to split them back correctly.',
            mnemonic: '"Encode with length" → s = str(len(word)) + "#" + word\n"Split by count" → length = int(s[:i]), then s[i+1:i+1+length]\n"Loop until done" → while i < len(s): decode',
            code: `class Solution:
    
    def encode(self, strs: List[str]) -> str:
        res = ""
        for s in strs:
            res += str(len(s)) + "#" + s
        return res

    def decode(self, s: str) -> List[str]:
        res = []
        i = 0
        
        while i < len(s):
            j = i
            while s[j] != '#':
                j += 1
            length = int(s[i:j])
            i = j + 1
            j = i + length
            res.append(s[i:j])
            i = j
            
        return res

# Time complexity: O(m) for each encode() and decode() function calls.
# Space complexity: O(m+n) for each encode() and decode() function calls`
          },
          {
            title: 'Product of Array Except Self',
            difficulty: 'Medium',
            question: 'Given an integer array nums, return an array output where output[i] is the product of all the elements of nums except nums[i].\n\nEach product is guaranteed to fit in a 32-bit integer.\n\nFollow-up: Could you solve it in O(n) time without using the division operation?\n\nExample 1:\n\nInput: nums = [1,2,4,6]\n\nOutput: [48,24,12,8]',
            hint: 'Try to solve this problem using two passes through the array, one from the left and one from the right.',
            oneLiner: 'Use prefix and suffix multiplications without division.',
            threeLiner: 'We find how much every number would be if we multiply all other numbers.\nFirst, we go left to right.\nThen, we go right to left and finish the math.',
            mnemonic: '"Left pass" → for i in range(n): res[i] *= prefix\n"Right pass" → for i in reversed(range(n)): res[i] *= suffix\n"Update prefixes" → prefix *= nums[i], suffix *= nums[i]',
            code: `class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        res = [1] * (len(nums))

        prefix = 1
        for i in range(len(nums)):
            res[i] = prefix
            prefix *= nums[i]
        postfix = 1
        for i in range(len(nums) - 1, -1, -1):
            res[i] *= postfix
            postfix *= nums[i]
        return res

# Time complexity: O(n)
# Space complexity: O(1) since the output array is excluded from space analysis.`
          },
          {
            title: 'Valid Sudoku',
            difficulty: 'Medium',
            question: 'You are given a 9 x 9 Sudoku board board. A Sudoku board is valid if the following rules are followed:\n\nEach row must contain the digits 1-9 without duplicates.\nEach column must contain the digits 1-9 without duplicates.\nEach of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without duplicates.\nReturn true if the Sudoku board is valid, otherwise return false\n\nNote: A board does not need to be full or be solvable to be valid.',
            hint: 'Use sets to track seen digits in each row, column, and 3x3 sub-box.',
            oneLiner: 'Use sets to check each row, column, and 3x3 box.',
            threeLiner: 'Each row, column, and box must have unique numbers.\nWe go through the board and record what we see.\nIf anything repeats in the same row, column, or box, it\'s not valid.',
            mnemonic: '"Check each cell" → for i in range(9): for j in range(9):\n"Use 3 keys" → row[i], col[j], box[i//3, j//3]\n"Add or return False" → if val in set: return False else: add',
            code: `class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        for row in range(9):
            seen = set()
            for i in range(9):
                if board[row][i] == ".": 
                    continue
                if board[row][i] in seen:
                    return False
                seen.add(board[row][i])
        
        for col in range(9):
            seen = set()
            for i in range(9):
                if board[i][col] == ".":
                    continue
                if board[i][col] in seen:
                    return False
                seen.add(board[i][col])
            
        for square in range(9):
            seen = set()
            for i in range(3):
                for j in range(3):
                    row = (square//3) * 3 + i
                    col = (square % 3) * 3 + j
                    if board[row][col] == ".":
                        continue
                    if board[row][col] in seen:
                        return False
                    seen.add(board[row][col])
        return True

# Time complexity: O(n^2)
# Space complexity: O(n^2)`
          },
          {
            title: 'Longest Consecutive Sequence',
            difficulty: 'Medium',
            question: 'Given an array of integers nums, return the length of the longest consecutive sequence of elements that can be formed.\n\nA consecutive sequence is a sequence of elements in which each element is exactly 1 greater than the previous element. The elements do not have to be consecutive in the original array.\n\nYou must write an algorithm that runs in O(n) time.\n\nExample 1:\n\nInput: nums = [2,20,4,10,3,4,5]\n\nOutput: 4',
            hint: 'Consider using a Set data structure to optimize lookups when checking for consecutive elements.',
            oneLiner: 'Use a set and expand sequences from the smallest number.',
            threeLiner: 'We put all the numbers in a quick lookup set.\nThen we start from numbers that are the beginning of a sequence.\nWe count how long each chain goes.',
            mnemonic: '"Add to set" → num_set = set(nums)\n"Start from beginning" → if num - 1 not in num_set:\n"Expand right" → while num + streak in num_set: streak += 1',
            code: `class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        numSet = set(nums)
        longest = 0

        for num in numSet:
            if (num - 1) not in numSet:
                length = 1
                while (num + length) in numSet:
                    length += 1
                longest = max(length, longest)
        return longest

# Time complexity: O(n)
# Space complexity: O(n)`
          }
        ],
        twopointers: [
          {
            title: 'Valid Palindrome',
            difficulty: 'Easy',
            question: 'A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward.',
            hint: 'Use two pointers: one starting from the beginning and one from the end.',
            oneLiner: 'Clean the string and check if it equals its reverse, or use two pointers from both ends.',
            threeLiner: 'We ignore spaces, punctuation, and letter case.\nWe check if the remaining letters and numbers read the same forward and backward.\nWe can do this by comparing characters from both ends moving inward.',
            mnemonic: 'The "Mirror Check" - like looking at a word from both sides to see if they match.',
            code: `def isPalindrome(s):
    left, right = 0, len(s) - 1
    
    while left < right:
        # Skip non-alphanumeric characters
        while left < right and not s[left].isalnum():
            left += 1
        while left < right and not s[right].isalnum():
            right -= 1
            
        # Compare characters (case-insensitive)
        if s[left].lower() != s[right].lower():
            return False
            
        left += 1
        right -= 1
        
    return True

# Time Complexity: O(n)
# Space Complexity: O(1)`
          }
        ],
        stack: [
          {
            title: 'Valid Parentheses',
            difficulty: 'Easy',
            question: 'Given a string s containing just the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\', determine if the input string is valid.',
            hint: 'Use a stack to keep track of opening brackets.',
            oneLiner: 'Use a stack to match opening and closing brackets.',
            threeLiner: 'We push opening brackets onto a stack.\nWhen we see a closing bracket, it must match the last opening bracket.\nIf everything matches and the stack is empty at the end, it\'s valid.',
            mnemonic: 'The "Bracket Matcher" - like pairing left and right gloves.',
            code: `def isValid(s):
    stack = []
    mapping = {")": "(", "}": "{", "]": "["}
    
    for char in s:
        if char in mapping:  # closing bracket
            top_element = stack.pop() if stack else '#'
            if mapping[char] != top_element:
                return False
        else:  # opening bracket
            stack.append(char)
    
    return not stack  # stack should be empty at the end

# Time Complexity: O(n)
# Space Complexity: O(n)`
          }
        ],
        binarysearch: [
          {
            title: 'Binary Search',
            difficulty: 'Easy',
            question: 'Given a sorted array, return the index of target. If not found, return -1.',
            hint: 'Use the binary search algorithm by repeatedly dividing the search interval in half.',
            oneLiner: 'Use two pointers to repeatedly cut the search range in half.',
            threeLiner: 'We look in the middle of the list.\nIf it\'s not the number, we search only the left or right part.\nWe do this again and again until we find it or run out.',
            mnemonic: '"Set range" → low, high = 0, len(nums) - 1\n"Check mid" → mid = (low + high) // 2\n"Narrow search" → if nums[mid] < target: low = mid + 1 else: high = mid - 1',
            code: `def binarySearch(nums: list[int], target: int) -> int:
    left, right = 0, len(nums) - 1
    
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
            
    return -1

# Time Complexity: O(log N)
# Space Complexity: O(1)`
          },
          {
            title: 'Search a 2D Matrix',
            difficulty: 'Medium',
            question: 'Given an m x n matrix where rows and columns are sorted, search for a target value.',
            hint: 'Consider treating the 2D matrix as a 1D sorted array.',
            oneLiner: 'Treat the 2D matrix like a 1D array and use binary search.',
            threeLiner: 'We pretend the grid is just one long list.\nWe use binary search on that list.\nWe change the middle number back to row and column to check it.',
            mnemonic: '"Convert index" → row = mid // cols; col = mid % cols\n"Compare mid" → if matrix[row][col] == target: return True\n"Adjust range" → low = mid + 1 or high = mid - 1',
            code: `def searchMatrix(matrix: list[list[int]], target: int) -> bool:
    if not matrix or not matrix[0]:
        return False
    
    rows, cols = len(matrix), len(matrix[0])
    left, right = 0, rows * cols - 1
    
    while left <= right:
        mid = (left + right) // 2
        mid_value = matrix[mid // cols][mid % cols]
        
        if mid_value == target:
            return True
        elif mid_value < target:
            left = mid + 1
        else:
            right = mid - 1
            
    return False

# Time Complexity: O(log(m × n))
# Space Complexity: O(1)`
          },
          {
            title: 'Koko Eating Bananas',
            difficulty: 'Medium',
            question: 'Find the minimum eating speed k such that Koko can eat all bananas within h hours.',
            hint: 'Try different eating speeds using binary search.',
            oneLiner: 'Binary search the eating speed to find the minimum speed that finishes on time.',
            threeLiner: 'We try different eating speeds.\nIf she can finish in time, we try slower ones.\nIf not, we try faster ones.',
            mnemonic: '"Search range" → low, high = 1, max(piles)\n"Check time" → total_time = sum(ceil(pile / mid))\n"Narrow search" → if time <= h: try slower; else: go faster',
            code: `import math

def minEatingSpeed(piles: list[int], h: int) -> int:
    left, right = 1, max(piles)
    
    def canFinish(speed):
        return sum(math.ceil(pile / speed) for pile in piles) <= h
    
    while left < right:
        mid = (left + right) // 2
        if canFinish(mid):
            right = mid
        else:
            left = mid + 1
            
    return left

# Time Complexity: O(N log M) where M is max pile size
# Space Complexity: O(1)`
          },
          {
            title: 'Find Minimum in Rotated Sorted Array',
            difficulty: 'Medium',
            question: 'Find the minimum element in a rotated sorted array.',
            hint: 'Think about which half the minimum element must be in.',
            oneLiner: 'Use binary search to find the smallest element by comparing with the rightmost.',
            threeLiner: 'The smallest number is in the rotated part.\nWe keep checking the middle and comparing to the end.\nWe move left or right depending on which side is sorted.',
            mnemonic: '"Mid vs right" → if nums[mid] > nums[right]: search right\n"Else search left" → right = mid\n"Result is nums[left]" → return nums[left]',
            code: `def findMin(nums: list[int]) -> int:
    left, right = 0, len(nums) - 1
    
    while left < right:
        mid = (left + right) // 2
        if nums[mid] > nums[right]:  
            left = mid + 1
        else:
            right = mid  
            
    return nums[left]

# Time Complexity: O(log N)
# Space Complexity: O(1)`
          },
          {
            title: 'Search in Rotated Sorted Array',
            difficulty: 'Medium',
            question: 'Search for target in a rotated sorted array.',
            hint: 'First identify which half is sorted, then determine if target lies in that half.',
            oneLiner: 'Binary search while checking which half is sorted and target range.',
            threeLiner: 'We split the list in half each time.\nWe check which half is in order.\nThen we pick the side where the target can be.',
            mnemonic: '"Left sorted?" → if nums[low] <= nums[mid]:\n"Target in left?" → if nums[low] <= target < nums[mid]: high = mid - 1\n"Otherwise search right" → low = mid + 1',
            code: `def search(nums: list[int], target: int) -> int:
    left, right = 0, len(nums) - 1
    
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        if nums[left] <= nums[mid]:  
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:  
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
                
    return -1

# Time Complexity: O(log N)
# Space Complexity: O(1)`
          },
          {
            title: 'Time-Based Key-Value Store',
            difficulty: 'Medium',
            question: 'Implement a key-value store that supports setting values with timestamps and retrieving the most recent value before a given timestamp.',
            hint: 'Store values in a sorted order and use binary search to find the appropriate value.',
            oneLiner: 'Store timestamped values in a list and binary search for the latest one <= target time.',
            threeLiner: 'We save every version of a value with the time it was saved.\nWhen asked for a time, we look for the latest version at or before that time.\nWe do this using binary search.',
            mnemonic: '"Store as list" → store[key].append((timestamp, value))\n"Binary search timestamp" → while low <= high: check mid time\n"Return latest <= timestamp" → res = value if time <= target',
            code: `from collections import defaultdict
import bisect

class TimeMap:
    def __init__(self):
        self.store = defaultdict(list)

    def set(self, key: str, value: str, timestamp: int) -> None:
        self.store[key].append((timestamp, value))

    def get(self, key: str, timestamp: int) -> str:
        if key not in self.store:
            return ""
        
        values = self.store[key]
        idx = bisect.bisect_right(values, (timestamp, chr(255))) - 1
        
        return values[idx][1] if idx >= 0 else ""

# Time Complexity:
# - set: O(1)
# - get: O(log N)
# Space Complexity: O(N)`
          },
          {
            title: 'Median of Two Sorted Arrays',
            difficulty: 'Hard',
            question: 'Find the median of two sorted arrays.',
            hint: 'Think about using binary search to find the correct partition of both arrays.',
            oneLiner: 'Use binary search to partition both arrays such that left half ≤ right half.',
            threeLiner: 'We cut both arrays in half in a smart way.\nWe want everything on the left half to be smaller than the right.\nWhen it\'s balanced, we take the middle numbers for the median.',
            mnemonic: '"Binary on smaller array" → if len(A) > len(B): swap\n"Partition and check" → Aleft <= Bright and Bleft <= Aright\n"Median calc" → if total even: avg of max(left), min(right); else: max(left)',
            code: `def findMedianSortedArrays(nums1: list[int], nums2: list[int]) -> float:
    if len(nums1) > len(nums2):
        nums1, nums2 = nums2, nums1  # Ensure nums1 is the smaller array

    x, y = len(nums1), len(nums2)
    left, right = 0, x

    while left <= right:
        partitionX = (left + right) // 2
        partitionY = (x + y + 1) // 2 - partitionX

        maxX = float('-inf') if partitionX == 0 else nums1[partitionX - 1]
        minX = float('inf') if partitionX == x else nums1[partitionX]
        maxY = float('-inf') if partitionY == 0 else nums2[partitionY - 1]
        minY = float('inf') if partitionY == y else nums2[partitionY]

        if maxX <= minY and maxY <= minX:
            if (x + y) % 2 == 0:
                return (max(maxX, maxY) + min(minX, minY)) / 2
            else:
                return max(maxX, maxY)
        elif maxX > minY:
            right = partitionX - 1
        else:
            left = partitionX + 1
            
# Time Complexity: O(log min(N, M))
# Space Complexity: O(1)`
          }
        ],
        slidingwindow: [
          {
            title: 'Best Time to Buy and Sell Stock',
            difficulty: 'Easy',
            question: 'You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy and a single day to sell.',
            hint: 'Keep track of the minimum price you\'ve seen so far, and calculate the maximum profit as you go through the array.',
            oneLiner: 'Track the minimum price and find the maximum profit as you scan.',
            threeLiner: 'We need to buy at a low price and sell at a higher price later.\nWe keep track of the lowest price we\'ve seen so far.\nAt each day, we calculate profit = current price - lowest price, and update our max profit.',
            mnemonic: 'The "Bargain Hunter" - like buying at lowest price and selling at highest after.',
            code: `def maxProfit(prices):
    if not prices:
        return 0
        
    max_profit = 0
    min_price = float('inf')
    
    for price in prices:
        min_price = min(min_price, price)
        current_profit = price - min_price
        max_profit = max(max_profit, current_profit)
    
    return max_profit

# Time Complexity: O(n)
# Space Complexity: O(1)`
          }
        ],
        linkedlist: [
          {
            title: 'Reverse Linked List',
            difficulty: 'Easy',
            question: 'Given the head of a singly linked list, reverse the list, and return the reversed list.',
            hint: 'Use three pointers to track the previous, current, and next nodes.',
            oneLiner: 'Iterate with prev, current, and next pointers to reverse links.',
            threeLiner: 'We keep track of three nodes: the previous, current, and next.\nWe update the current node to point to the previous one instead of the next.\nThen we move all our pointers forward and repeat until we\'ve processed all nodes.',
            mnemonic: 'The "Arrow Flipper" - like changing the direction of all arrows in a path.',
            code: `def reverseList(head):
    prev = None
    current = head
    
    while current:
        next_temp = current.next
        current.next = prev
        prev = current
        current = next_temp
        
    return prev

# Time Complexity: O(n)
# Space Complexity: O(1)`
          }
        ],
        trees: [
          {
            title: 'Maximum Depth of Binary Tree',
            difficulty: 'Easy',
            question: 'Given the root of a binary tree, return its maximum depth. A binary tree\'s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.',
            hint: 'Use recursion to find the depth of the left and right subtrees.',
            oneLiner: 'Use recursion to find the maximum of left and right subtree depths, plus one.',
            threeLiner: 'We use recursion to solve this problem.\nFor each node, we find the maximum depth of its left and right subtrees.\nWe add 1 to account for the current node and return the result.',
            mnemonic: 'The "Tree Height Finder" - like measuring the height of a tree.',
            code: `def maxDepth(root):
    if not root:
        return 0
        
    left_depth = maxDepth(root.left)
    right_depth = maxDepth(root.right)
    
    return max(left_depth, right_depth) + 1

# Time Complexity: O(n)
# Space Complexity: O(h) where h is the height of the tree`
          }
        ],
        tries: [
          {
            title: 'Implement Trie (Prefix Tree)',
            difficulty: 'Medium',
            question: 'Implement a trie with insert, search, and startsWith methods.',
            hint: 'Use a tree structure where each node has a dictionary of children.',
            oneLiner: 'Create a tree where each node represents a letter in a word path.',
            threeLiner: 'We build a tree where each node has links to next characters.\nEach node also keeps track if it\'s the end of a word.\nWe walk the tree to insert and query words and prefixes.',
            mnemonic: 'The "Word Explorer" - like navigating a dictionary by following letter paths.',
            code: `class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end_of_word = False

class Trie:
    def __init__(self):
        self.root = TrieNode()
        
    def insert(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end_of_word = True
        
    def search(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        return node.is_end_of_word
        
    def startsWith(self, prefix):
        node = self.root
        for char in prefix:
            if char not in node.children:
                return False
            node = node.children[char]
        return True

# Time Complexity: O(m) for all operations, where m is the length of the word
# Space Complexity: O(m * n) where n is the number of words`
          }
        ],
        backtracking: [
          {
            title: 'Subsets',
            difficulty: 'Medium',
            question: 'Generate all possible subsets of a given set of distinct integers.',
            hint: 'Use backtracking to generate all possible combinations.',
            oneLiner: 'Use backtracking to include or exclude each number.',
            threeLiner: 'We pick numbers one by one.\nEach time, we decide to keep it or skip it.\nThat gives us all possible combinations.',
            mnemonic: '"Start with empty list" → res = [[]]\n"Try adding" → dfs(index + 1, path + [nums[i]])\n"Try skipping" → dfs(index + 1, path)',
            code: `def subsets(nums):
    result = []
    def backtrack(start, path):
        result.append(path)
        for i in range(start, len(nums)):
            backtrack(i + 1, path + [nums[i]])
    backtrack(0, [])
    return result

# Time Complexity: O(2^N)
# Space Complexity: O(N)`
          },
          {
            title: 'Combination Sum',
            difficulty: 'Medium',
            question: 'Find all unique combinations of candidates where the chosen numbers sum to a target. Each number in candidates may be used unlimited times.',
            hint: 'Use a recursive approach to try all combinations, with an option to reuse the same number.',
            oneLiner: 'Use DFS to try combinations, reusing the same number.',
            threeLiner: 'We keep adding numbers until we hit the target.\nWe can use the same number again.\nIf it\'s too much, we stop and go back.',
            mnemonic: '"Base case" → if target == 0: add path\n"Too big" → if target < 0: return\n"Try again" → dfs(i, path + [candidates[i]], target - candidates[i])',
            code: `def combinationSum(candidates, target):
    result = []
    def backtrack(start, target, path):
        if target == 0:
            result.append(path)
            return
        for i in range(start, len(candidates)):
            if candidates[i] > target:
                continue
            backtrack(i, target - candidates[i], path + [candidates[i]])
    candidates.sort()
    backtrack(0, target, [])
    return result

# Time Complexity: O(N^(T/M)) where T is target and M is minimum value 
# Space Complexity: O(T/M)`
          },
          {
            title: 'Combination Sum II',
            difficulty: 'Medium',
            question: 'Find all unique combinations in candidates where the chosen numbers sum to target. Each number in candidates may only be used once. The solution set must not contain duplicate combinations.',
            hint: 'Sort the input array to handle duplicates and use backtracking to find the combinations.',
            oneLiner: 'Like Combination Sum but skip duplicates and don\'t reuse elements.',
            threeLiner: 'We can\'t use the same number again.\nWe also skip duplicates to avoid repeat combos.\nWe keep trying until the sum matches the target.',
            mnemonic: '"Sort first" → candidates.sort()\n"Skip duplicates" → if i > start and candidates[i] == candidates[i - 1]: continue\n"DFS without reuse" → dfs(i + 1, path + [candidates[i]], target - candidates[i])',
            code: `def combinationSum2(candidates, target):
    result = []
    candidates.sort()
    def backtrack(start, target, path):
        if target == 0:
            result.append(path)
            return
        prev = -1
        for i in range(start, len(candidates)):
            if candidates[i] == prev:
                continue
            if candidates[i] > target:
                break
            backtrack(i + 1, target - candidates[i], path + [candidates[i]])
            prev = candidates[i]
    backtrack(0, target, [])
    return result

# Time Complexity: O(2^N)
# Space Complexity: O(N)`
          },
          {
            title: 'Permutations',
            difficulty: 'Medium',
            question: 'Return all possible permutations of a list of distinct integers.',
            hint: 'Use backtracking to build the permutations by choosing one element at a time.',
            oneLiner: 'Use backtracking to build all possible orders.',
            threeLiner: 'We make all different orders of the numbers.\nWe pick one at a time and don\'t repeat it.\nWhen the list is full, we save it.',
            mnemonic: '"Track used" → if num in used: continue\n"Choose number" → path.append(num)\n"Backtrack" → path.pop() and used.remove(num)',
            code: `def permute(nums):
    result = []
    def backtrack(path, options):
        if not options:
            result.append(path)
            return
        for i in range(len(options)):
            backtrack(path + [options[i]], options[:i] + options[i+1:])
    backtrack([], nums)
    return result

# Time Complexity: O(N!)
# Space Complexity: O(N)`
          },
          {
            title: 'Subsets II',
            difficulty: 'Medium',
            question: 'Return all possible subsets of a list of integers that might contain duplicates. The solution set must not contain duplicate subsets.',
            hint: 'Sort the input to handle duplicates and use backtracking to generate subsets.',
            oneLiner: 'Backtracking with duplicate skip using sorted input.',
            threeLiner: 'Like normal subsets, but now we skip duplicates.\nWe sort the list so we can spot repeats.\nWe only use the first time a number shows up at a level.',
            mnemonic: '"Sort input" → nums.sort()\n"Skip repeat at level" → if i > start and nums[i] == nums[i - 1]: continue\n"DFS normally" → dfs(i + 1, path + [nums[i]])',
            code: `def subsetsWithDup(nums):
    result = []
    nums.sort()
    def backtrack(start, path):
        result.append(path)
        for i in range(start, len(nums)):
            if i > start and nums[i] == nums[i - 1]:
                continue
            backtrack(i + 1, path + [nums[i]])
    backtrack(0, [])
    return result

# Time Complexity: O(2^N)
# Space Complexity: O(N)`
          },
          {
            title: 'Word Search',
            difficulty: 'Medium',
            question: 'Given an m x n board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cells.',
            hint: 'Use backtracking to explore all possible paths starting from each cell.',
            oneLiner: 'Backtrack through board cells matching word letters.',
            threeLiner: 'We try to find each letter one by one.\nWe can only move up/down/left/right.\nIf it works, we return true!',
            mnemonic: '"Check match" → if board[i][j] != word[pos]: return\n"Mark visited" → board[i][j] = \'#\'\n"Unmark (backtrack)" → board[i][j] = original_letter',
            code: `def exist(board, word):
    rows, cols = len(board), len(board[0])
    def backtrack(r, c, index):
        if index == len(word):
            return True
        if r < 0 or r >= rows or c < 0 or c >= cols or board[r][c] != word[index]:
            return False
        temp, board[r][c] = board[r][c], '#'
        found = (backtrack(r+1, c, index+1) or
                 backtrack(r-1, c, index+1) or
                 backtrack(r, c+1, index+1) or
                 backtrack(r, c-1, index+1))
        board[r][c] = temp
        return found
    for r in range(rows):
        for c in range(cols):
            if backtrack(r, c, 0):
                return True
    return False

# Time Complexity: O(M * N * 4^L) where L is word length
# Space Complexity: O(L)`
          },
          {
            title: 'Palindrome Partitioning',
            difficulty: 'Medium',
            question: 'Partition a string such that every substring is a palindrome. Return all possible palindrome partitioning of the string.',
            hint: 'Use backtracking to explore all possible ways to cut the string, checking if each piece is a palindrome.',
            oneLiner: 'Use backtracking to cut the string at every palindrome point.',
            threeLiner: 'We break the string into pieces.\nOnly cut when the piece is a palindrome.\nWe keep cutting until the whole string is split.',
            mnemonic: '"Check palindrome" → if s[l:r+1] == s[l:r+1][::-1]\n"Cut and continue" → dfs(end + 1, path + [s[start:end+1]])\n"Add to result" → if start == len(s): res.append(path)',
            code: `def partition(s):
    result = []
    def is_palindrome(sub):
        return sub == sub[::-1]
    def backtrack(start, path):
        if start == len(s):
            result.append(path)
            return
        for end in range(start + 1, len(s) + 1):
            if is_palindrome(s[start:end]):
                backtrack(end, path + [s[start:end]])
    backtrack(0, [])
    return result

# Time Complexity: O(2^N)
# Space Complexity: O(N)`
          },
          {
            title: 'Letter Combinations of a Phone Number',
            difficulty: 'Medium',
            question: 'Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.',
            hint: 'Use a mapping of digits to letters and backtracking to generate all combinations.',
            oneLiner: 'Backtrack all digit-letter mappings like a tree.',
            threeLiner: 'Each number maps to letters.\nWe pick one letter per number.\nWe try every combination possible.',
            mnemonic: '"Map digits" → digit_map = {\'2\': \'abc\', ...}\n"For each digit" → for letter in digit_map[digit]:\n"Backtrack" → dfs(index + 1, path + letter)',
            code: `def letterCombinations(digits):
    if not digits:
        return []
    phone = {
        '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl',
        '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'
    }
    result = []
    def backtrack(index, path):
        if index == len(digits):
            result.append(path)
            return
        for char in phone[digits[index]]:
            backtrack(index + 1, path + char)
    backtrack(0, '')
    return result

# Time Complexity: O(4^N) where N is number of digits
# Space Complexity: O(N)`
          },
          {
            title: 'N-Queens',
            difficulty: 'Hard',
            question: 'The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Return all distinct solutions.',
            hint: 'Place queens row by row and check if it\'s safe to place a queen at each position.',
            oneLiner: 'Place queens row by row, checking for safe spots.',
            threeLiner: 'We try to put queens one row at a time.\nWe make sure they don\'t attack each other.\nIf it works, we save the board setup.',
            mnemonic: '"Loop columns" → for col in range(n):\n"Check safe" → if col not in cols and row+col not in diag1 and row-col not in diag2\n"Place & recurse" → dfs(row + 1) and backtrack positions',
            code: `def solveNQueens(n):
    result = []
    
    # Initialize the chessboard
    chessboard = [['.' for _ in range(n)] for _ in range(n)]
    
    # Sets to track occupied columns and diagonals
    cols = set()
    diag1 = set()  # r + c
    diag2 = set()  # r - c
    
    def backtrack(r):
        if r == n:
            # When we've placed all n queens successfully
            board = [''.join(row) for row in chessboard]
            result.append(board)
            return
        
        for c in range(n):
            # Check if current position is under attack
            if c in cols or (r + c) in diag1 or (r - c) in diag2:
                continue
                
            # Place the queen
            cols.add(c)
            diag1.add(r + c)
            diag2.add(r - c)
            chessboard[r][c] = 'Q'
            
            # Move to the next row
            backtrack(r + 1)
            
            # Backtrack
            cols.remove(c)
            diag1.remove(r + c)
            diag2.remove(r - c)
            chessboard[r][c] = '.'
    
    backtrack(0)
    return result

# Time Complexity: O(N!)
# Space Complexity: O(N)`
          }
        ],
        heap: [
          {
            title: 'Kth Largest Element in an Array',
            difficulty: 'Medium',
            question: 'Given an integer array nums and an integer k, return the kth largest element in the array.',
            hint: 'Use a min-heap of size k to keep track of the k largest elements.',
            oneLiner: 'Use a min-heap of size k to track the k largest values.',
            threeLiner: 'We maintain a heap with the k largest elements seen so far.\nWe keep the smallest of the k largest at the top for quick access.\nThis way, we can compare new elements with it and keep only the k largest.',
            mnemonic: 'The "Top K Tracker" - like maintaining a leaderboard of the k highest scores.',
            code: `import heapq

def findKthLargest(nums, k):
    min_heap = []
    
    for num in nums:
        if len(min_heap) < k:
            heapq.heappush(min_heap, num)
        elif num > min_heap[0]:
            heapq.heappop(min_heap)
            heapq.heappush(min_heap, num)
    
    return min_heap[0]

# Time Complexity: O(n log k)
# Space Complexity: O(k)`
          }
        ],
        intervals: [
          {
            title: 'Merge Intervals',
            difficulty: 'Medium',
            question: 'Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals.',
            hint: 'Sort the intervals by their start time, then merge overlapping intervals.',
            oneLiner: 'Sort by start time and merge overlapping intervals sequentially.',
            threeLiner: 'First, we sort the intervals by their start times.\nThen we add the first interval to our result and check each next interval.\nIf it overlaps with the last interval in our result, we merge them; otherwise, we add it as a new interval.',
            mnemonic: 'The "Appointment Combiner" - like merging overlapping meetings in a calendar.',
            code: `def merge(intervals):
    if not intervals:
        return []
    
    # Sort by start time
    intervals.sort(key=lambda x: x[0])
    
    merged = [intervals[0]]
    
    for i in range(1, len(intervals)):
        current = intervals[i]
        previous = merged[-1]
        
        # If current interval overlaps with previous
        if current[0] <= previous[1]:
            # Merge by updating end time of previous
            previous[1] = max(previous[1], current[1])
        else:
            # No overlap, add current interval
            merged.append(current)
    
    return merged

# Time Complexity: O(n log n) due to sorting
# Space Complexity: O(n) for the output array`
          }
        ],
        greedy: [
          {
            title: 'Jump Game',
            difficulty: 'Medium',
            question: 'You are given an integer array nums. You are initially positioned at the first index of the array and each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index.',
            hint: 'Keep track of the furthest position you can reach.',
            oneLiner: 'Track the farthest position you can reach and update as you go.',
            threeLiner: 'We keep track of the farthest position we can reach.\nAs we pass through the array, we update this farthest reach.\nIf at any point we can\'t reach the current position, we know we\'ll fail.',
            mnemonic: 'The "Furthest Reach Tracker" - like marking the furthest point you can reach at any step.',
            code: `def canJump(nums):
    max_reach = 0
    
    for i, jump in enumerate(nums):
        # If we can't reach the current position, we can't go further
        if i > max_reach:
            return False
            
        # Update the furthest we can reach
        max_reach = max(max_reach, i + jump)
        
        # If we can reach the end, return early
        if max_reach >= len(nums) - 1:
            return True
    
    return True

# Time Complexity: O(n)
# Space Complexity: O(1)`
          }
        ],
        advancedgraphs: [
          {
            title: 'Network Delay Time',
            difficulty: 'Medium',
            question: 'You are given a network of n nodes, labeled from 1 to n. You are also given times, a list of travel times as directed edges where times[i] = (ui, vi, wi) means node ui to node vi takes wi time. Return the minimum time it takes for all the n nodes to receive the signal, or -1 if it is impossible.',
            hint: 'Use Dijkstra\'s algorithm to find the shortest path from the source to all other nodes.',
            oneLiner: 'Use Dijkstra\'s algorithm to find shortest time to all nodes.',
            threeLiner: 'We send a signal from one point.\nWe figure out how fast it can reach every other point.\nThe longest of those times is our answer.',
            mnemonic: '"Build graph" → graph[u].append((v, w))\n"Min-heap Dijkstra" → heappop(heap) gives node with smallest time\n"Update time" → if new_time < dist[v]: update and push',
            code: `class Solution:
    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:
        edges = collections.defaultdict(list)
        for u, v, w in times:
            edges[u].append((v, w))

        minHeap = [(0, k)]
        visit = set()
        t = 0
        while minHeap:
            w1, n1 = heapq.heappop(minHeap)
            if n1 in visit:
                continue
            visit.add(n1)
            t = w1

            for n2, w2 in edges[n1]:
                if n2 not in visit:
                    heapq.heappush(minHeap, (w1 + w2, n2))
        return t if len(visit) == n else -1

# Time Complexity: O(E log V) where E is the number of edges and V is the number of nodes
# Space Complexity: O(E + V)`
          },
          {
            title: 'Reconstruct Itinerary',
            difficulty: 'Hard',
            question: 'Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK. If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.',
            hint: 'Use depth-first search with backtracking to find the lexicographically smallest valid itinerary.',
            oneLiner: 'Use DFS + min-heap to build lexicographically smallest itinerary.',
            threeLiner: 'We treat each airport as a point.\nWe travel using the smallest possible word (alphabetically).\nWhen all tickets are used, that\'s our path.',
            mnemonic: '"Build min-heap graph" → graph[frm].append(to); heapify\n"DFS visit" → while graph[airport]: dfs(next_dest)\n"Build itinerary" → res.appendleft(airport)',
            code: `class Solution:
    def findItinerary(self, tickets: List[List[str]]) -> List[str]:
        adj = defaultdict(list)
        for src, dst in sorted(tickets)[::-1]:
            adj[src].append(dst)
            
        stack = ["JFK"]
        res = []
        
        while stack:
            curr = stack[-1]
            if not adj[curr]:
                res.append(stack.pop())
            else:
                stack.append(adj[curr].pop())
                
        return res[::-1]

# Time Complexity: O(E log E), where E is the number of edges (tickets)
# Space Complexity: O(V + E), where V is the number of vertices (airports)`
          },
          {
            title: 'Min Cost to Connect All Points',
            difficulty: 'Medium',
            question: 'You are given an array points representing integer coordinates of some points on a 2D-plane, where points[i] = [xi, yi]. The cost of connecting two points [xi, yi] and [xj, yj] is the manhattan distance between them: |xi - xj| + |yi - yj|. Return the minimum cost to make all points connected.',
            hint: 'This is a Minimum Spanning Tree (MST) problem. Consider using Prim\'s or Kruskal\'s algorithm.',
            oneLiner: 'Use Prim\'s algorithm (MST) with min-heap for Manhattan distances.',
            threeLiner: 'We connect all dots with the least total cost.\nWe always choose the shortest connection that\'s not yet used.\nWhen all points are connected, we stop.',
            mnemonic: '"Heap init" → heap = [(0, 0)] (cost, node)\n"Track visited" → if node not in visited: add to cost\n"Push neighbors" → for every next_point: heappush with distance',
            code: `class Solution:
    def minCostConnectPoints(self, points: List[List[int]]) -> int:
        n, node = len(points), 0
        dist = [100000000] * n
        visit = [False] * n
        edges, res = 0, 0

        while edges < n - 1:
            visit[node] = True
            nextNode = -1
            for i in range(n):
                if visit[i]:
                    continue
                curDist = (abs(points[i][0] - points[node][0]) + 
                           abs(points[i][1] - points[node][1]))
                dist[i] = min(dist[i], curDist)
                if nextNode == -1 or dist[i] < dist[nextNode]:
                    nextNode = i
                    
            res += dist[nextNode]
            node = nextNode
            edges += 1

        return res

# Time Complexity: O(n²) where n is the number of points
# Space Complexity: O(n)`
          },
          {
            title: 'Swim in Rising Water',
            difficulty: 'Hard',
            question: 'On an N x N grid, each square has a height. At time t, the water level is at height t. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. Return the least time until you can reach the bottom right square (N-1, N-1) if you start at the top left square (0, 0).',
            hint: 'Think of using a priority queue to always explore the path with the minimum maximum height.',
            oneLiner: 'Use Dijkstra-style BFS to always swim in the minimum rising level.',
            threeLiner: 'We treat the grid like a pool filling up.\nWe can only move to spots that are less than or equal to the current water level.\nWe find the smallest max value along the path to the bottom.',
            mnemonic: '"Heap by elevation" → heappush(heap, (elevation, r, c))\n"Track max" → max_time = max(max_time, grid[r][c])\n"Stop at end" → if r == n-1 and c == n-1: return max_time',
            code: `class Solution:
    def swimInWater(self, grid: List[List[int]]) -> int:
        N = len(grid)
        visit = set()
        minH = [[grid[0][0], 0, 0]]  # (time/max-height, r, c)
        directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]

        visit.add((0, 0))
        while minH:
            t, r, c = heapq.heappop(minH)
            if r == N - 1 and c == N - 1:
                return t
            for dr, dc in directions:
                neiR, neiC = r + dr, c + dc
                if (neiR < 0 or neiC < 0 or 
                    neiR == N or neiC == N or
                    (neiR, neiC) in visit
                ):
                    continue
                visit.add((neiR, neiC))
                heapq.heappush(minH, [max(t, grid[neiR][neiC]), neiR, neiC])

# Time Complexity: O(n² log n) where n is the grid size
# Space Complexity: O(n²)`
          },
          {
            title: 'Alien Dictionary',
            difficulty: 'Hard',
            question: 'Given a sorted dictionary of alien words, find the order of characters in the alien language. The dictionary may contain duplicates and not all letters from the alien language may be used in the dictionary.',
            hint: 'Treat each character as a node in a graph, and create edges based on the order of characters in adjacent words.',
            oneLiner: 'Build graph from character order and use topological sort (BFS).',
            threeLiner: 'We look at word pairs to learn which letter comes first.\nWe build a graph of rules from those pairs.\nThen we sort the letters based on what comes before what.',
            mnemonic: '"Build graph" → if a != b: graph[a].append(b); indegree[b] += 1\n"Start with 0 indegree" → queue = letters with indegree 0\n"Topo sort" → while queue: pop letter, reduce indegrees',
            code: `class Solution:
    def foreignDictionary(self, words):
        adj = {c: set() for w in words for c in w}
        indegree = {c: 0 for c in adj}
        
        for i in range(len(words) - 1):
            w1, w2 = words[i], words[i + 1]
            minLen = min(len(w1), len(w2))
            if len(w1) > len(w2) and w1[:minLen] == w2[:minLen]:
                return ""
            for j in range(minLen):
                if w1[j] != w2[j]:
                    if w2[j] not in adj[w1[j]]:
                        adj[w1[j]].add(w2[j])
                        indegree[w2[j]] += 1
                    break
        
        q = deque([c for c in indegree if indegree[c] == 0])
        res = []
        
        while q:
            char = q.popleft()
            res.append(char)
            for neighbor in adj[char]:
                indegree[neighbor] -= 1
                if indegree[neighbor] == 0:
                    q.append(neighbor)
        
        if len(res) != len(indegree):
            return ""
        
        return "".join(res)

# Time Complexity: O(C) where C is the total length of all words
# Space Complexity: O(1) since there are at most 26 unique characters`
          },
          {
            title: 'Cheapest Flights Within K Stops',
            difficulty: 'Medium',
            question: 'There are n cities connected by some number of flights. You are given an array flights where flights[i] = [fromi, toi, pricei] indicates that there is a flight from city fromi to city toi with cost pricei. You are also given three integers src, dst, and k, return the cheapest price from src to dst with at most k stops. If there is no such route, return -1.',
            hint: 'Use a BFS-like approach, but keep track of the number of stops and the cost.',
            oneLiner: 'Use modified BFS (Bellman-Ford style) with (cost, node, stops).',
            threeLiner: 'We look for the cheapest flight path with limited stops.\nWe explore each city step by step.\nWe avoid paths that are too long or expensive.',
            mnemonic: '"Queue with stops" → heap = [(0, src, 0)]\n"If stops ≤ K" → push (cost + price, next, stops + 1)\n"Track cheapest" → if city == dst: return cost',
            code: `class Solution:
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:
        prices = [float("inf")] * n
        prices[src] = 0
        adj = [[] for _ in range(n)]
        for u, v, cst in flights:
            adj[u].append([v, cst])

        q = deque([(0, src, 0)])
        while q:
            cst, node, stops = q.popleft()
            if stops > k:
                continue
            
            for nei, w in adj[node]:
                nextCost = cst + w
                if nextCost < prices[nei]:
                    prices[nei] = nextCost
                    q.append((nextCost, nei, stops + 1))

        return prices[dst] if prices[dst] != float("inf") else -1

# Time Complexity: O(E * K) where E is the number of edges/flights and K is the maximum stops
# Space Complexity: O(V) where V is the number of vertices/cities`
          }
        ],
        graphs: [
          {
            title: 'Number of Islands',
            difficulty: 'Medium',
            question: 'Given an m x n 2D binary grid grid which represents a map of \'1\'s (land) and \'0\'s (water), return the number of islands.',
            hint: 'Use DFS or BFS to explore all connected land cells, marking them as visited.',
            oneLiner: 'Use DFS/BFS to find connected land components in the grid.',
            threeLiner: 'We search the grid for land cells (1\'s).\nWhen we find one, we use DFS or BFS to explore all connected land cells and mark them as visited.\nEach time we start a new exploration, we count a new island.',
            mnemonic: 'The "Land Explorer" - like discovering and marking all connected pieces of land.',
            code: `def numIslands(grid):
    if not grid:
        return 0
        
    rows, cols = len(grid), len(grid[0])
    count = 0
    
    def dfs(r, c):
        if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == '0':
            return
            
        # Mark as visited
        grid[r][c] = '0'
        
        # Explore all 4 directions
        dfs(r + 1, c)
        dfs(r - 1, c)
        dfs(r, c + 1)
        dfs(r, c - 1)
    
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == '1':
                count += 1
                dfs(r, c)
    
    return count

# Time Complexity: O(m * n) where m and n are the dimensions of the grid
# Space Complexity: O(m * n) for the recursion stack in worst case`
          }
        ],
        dp1d: [
          {
            title: 'Climbing Stairs',
            difficulty: 'Easy',
            question: 'You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?',
            hint: 'The number of ways to reach step n is the sum of ways to reach steps n-1 and n-2.',
            oneLiner: 'Calculate ways to reach each step using the sum of previous two steps.',
            threeLiner: 'To reach a step, we can either come from one step before or two steps before.\nSo ways to reach step n = ways to reach step n-1 + ways to reach step n-2.\nThis is exactly like the Fibonacci sequence pattern.',
            mnemonic: 'The "Fibonacci Climber" - like calculating Fibonacci numbers for each step.',
            code: `def climbStairs(n):
    if n <= 2:
        return n
        
    # Initialize first two steps
    prev1, prev2 = 1, 2
    
    # Calculate ways for subsequent steps
    for i in range(3, n + 1):
        current = prev1 + prev2
        prev1, prev2 = prev2, current
    
    return prev2

# Time Complexity: O(n)
# Space Complexity: O(1)`
          }
        ],
        dp2d: [
          {
            title: 'Unique Paths',
            difficulty: 'Medium',
            question: 'A robot is located at the top-left corner of a m x n grid. The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid. How many possible unique paths are there?',
            hint: 'The number of ways to reach a cell is the sum of ways to reach the cell above it and the cell to its left.',
            oneLiner: 'For each cell, paths = paths from above + paths from left.',
            threeLiner: 'We fill a grid where each cell stores the number of paths to reach it.\nTo reach any cell, we must come from either above or left.\nSo paths to cell (i,j) = paths to (i-1,j) + paths to (i,j-1).',
            mnemonic: 'The "Path Counter" - like counting all possible routes on a map.',
            code: `def uniquePaths(m, n):
    # Create a 2D DP table
    dp = [[1 for _ in range(n)] for _ in range(m)]
    
    # Fill the DP table
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
    
    return dp[m-1][n-1]

# Time Complexity: O(m * n)
# Space Complexity: O(m * n)`
          }
        ],
        bitmanipulation: [
          {
            title: 'Single Number',
            difficulty: 'Easy',
            question: 'Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.',
            hint: 'Think about using bitwise operations. XOR has an interesting property: n ^ n = 0.',
            oneLiner: 'Use XOR to find the only non-repeated number.',
            threeLiner: 'We know that XOR (^) of a number with itself is 0.\nAnd XOR of a number with 0 is the number itself.\nSo XORing all numbers will cancel out pairs, leaving only the single number.',
            mnemonic: 'The "XOR Eliminator" - like items canceling out in pairs, leaving the odd one out.',
            code: `def singleNumber(nums):
    result = 0
    for num in nums:
        result ^= num
    return result

# Time Complexity: O(n)
# Space Complexity: O(1)`
          }
        ],
        mathgeometry: [
          {
            title: 'Happy Number',
            difficulty: 'Easy',
            question: 'Write an algorithm to determine if a number n is happy. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.',
            hint: 'Use a hash set to detect cycles.',
            oneLiner: 'Use a set to detect cycles and check if we reach 1.',
            threeLiner: 'We calculate the sum of squares of digits repeatedly.\nWe use a set to detect if we\'ve seen a number before (which means we\'re in a cycle).\nIf we reach 1, it\'s a happy number; if we find a cycle without reaching 1, it\'s not.',
            mnemonic: 'The "Square and Sum Cycle Detector" - like tracking a process that either reaches happiness or cycles endlessly.',
            code: `def isHappy(n):
    seen = set()
    
    while n != 1 and n not in seen:
        seen.add(n)
        n = sum(int(digit) ** 2 for digit in str(n))
    
    return n == 1

# Time Complexity: O(log n)
# Space Complexity: O(log n)`
          }
        ]
      };

      // DOM elements
      const topicSection = document.getElementById('topic-section');
      const topicGrid = document.getElementById('topic-grid');
      const flashcardSection = document.getElementById('flashcard-section');
      const backButton = document.getElementById('back-button');
      const currentTopic = document.getElementById('current-topic');
      const problemCounter = document.getElementById('problem-counter');
      const prevButton = document.getElementById('prev-button');
      const nextButton = document.getElementById('next-button');
      const flashcard = document.getElementById('flashcard');
      
      // State variables
      let selectedTopicId = null;
      let currentProblemIndex = 0;

      // Populate topics
      function populateTopics() {
        console.log("Populating topics...");
        topicGrid.innerHTML = '';
        
        topics.forEach(topic => {
          const problemCount = problems[topic.id] ? problems[topic.id].length : 0;
          const status = problemCount > 0 ? `${problemCount} problems` : 'Coming soon';
          
          const card = document.createElement('div');
          card.className = 'bg-white hover:bg-blue-50 border border-gray-200 rounded-lg p-4 shadow-sm transition-colors';
          card.innerHTML = `
            <h3 class="font-medium text-gray-900">${topic.name}</h3>
            <p class="text-gray-500 text-sm mt-1">${status}</p>
          `;
          
          if (problemCount > 0) {
            card.style.cursor = 'pointer';
            card.addEventListener('click', () => selectTopic(topic.id));
          } else {
            card.classList.add('opacity-60');
            card.style.cursor = 'not-allowed';
          }
          
          topicGrid.appendChild(card);
        });
      }

      // Select a topic
      function selectTopic(topicId) {
        selectedTopicId = topicId;
        currentProblemIndex = 0;
        
        topicSection.classList.add('hidden');
        flashcardSection.classList.remove('hidden');
        
        const topic = topics.find(t => t.id === topicId);
        currentTopic.textContent = topic.name;
        
        loadProblem();
      }

      // Load current problem
      function loadProblem() {
        console.log("Loading problem...");
        const currentProblems = problems[selectedTopicId];
        console.log("Current problems:", currentProblems);
        const problem = currentProblems[currentProblemIndex];
        console.log("Current problem:", problem);
        
        // Update counter and navigation
        problemCounter.textContent = `Problem ${currentProblemIndex + 1} of ${currentProblems.length}`;
        prevButton.disabled = currentProblemIndex === 0;
        nextButton.disabled = currentProblemIndex === currentProblems.length - 1;
        
        // Reset card state
        flashcard.classList.remove('flipped');
        
        // Update front of card
        document.getElementById('card-title').textContent = problem.title;
        document.getElementById('card-title-back').textContent = `${problem.title} - Solution`;
        
        // Set difficulty badge
        const difficultyBadge = document.getElementById('card-difficulty');
        difficultyBadge.textContent = problem.difficulty;
        difficultyBadge.className = 'px-2 py-1 rounded-full text-xs font-semibold text-white';
        
        if (problem.difficulty === 'Easy') {
          difficultyBadge.classList.add('bg-green-500');
        } else if (problem.difficulty === 'Medium') {
          difficultyBadge.classList.add('bg-yellow-500');
        } else {
          difficultyBadge.classList.add('bg-red-500');
        }
        
        // Update content
        document.getElementById('question-content').textContent = problem.question;
        document.getElementById('hint-content').textContent = problem.hint;
        
        // Update new fields from the array problems
        if (problem.oneLiner) document.getElementById('one-liner-content').textContent = problem.oneLiner;
        if (problem.threeLiner) document.getElementById('three-liner-content').textContent = problem.threeLiner;
        document.getElementById('mnemonic-content').textContent = problem.mnemonic;
        document.getElementById('code-block').textContent = problem.code;
        
        // Reset tabs
        document.getElementById('question-tab').click();
        document.getElementById('one-liner-tab').click();
      }

      // Event listeners
      backButton.addEventListener('click', () => {
        flashcardSection.classList.add('hidden');
        topicSection.classList.remove('hidden');
      });
      
      prevButton.addEventListener('click', () => {
        if (currentProblemIndex > 0) {
          currentProblemIndex--;
          loadProblem();
        }
      });
      
      nextButton.addEventListener('click', () => {
        if (currentProblemIndex < problems[selectedTopicId].length - 1) {
          currentProblemIndex++;
          loadProblem();
        }
      });
      
      // Tab switching - front
      document.getElementById('question-tab').addEventListener('click', () => {
        document.getElementById('question-tab').classList.add('border-blue-500', 'text-blue-600');
        document.getElementById('hint-tab').classList.remove('border-blue-500', 'text-blue-600');
        document.getElementById('question-content').classList.remove('hidden');
        document.getElementById('hint-content').classList.add('hidden');
      });
      
      document.getElementById('hint-tab').addEventListener('click', () => {
        document.getElementById('hint-tab').classList.add('border-blue-500', 'text-blue-600');
        document.getElementById('question-tab').classList.remove('border-blue-500', 'text-blue-600');
        document.getElementById('hint-content').classList.remove('hidden');
        document.getElementById('question-content').classList.add('hidden');
      });
      
      // Tab switching - back
      document.getElementById('one-liner-tab').addEventListener('click', () => {
        document.getElementById('one-liner-tab').classList.add('border-blue-300', 'text-blue-300');
        document.getElementById('three-liner-tab').classList.remove('border-blue-300', 'text-blue-300');
        document.getElementById('mnemonic-tab').classList.remove('border-blue-300', 'text-blue-300');
        document.getElementById('code-tab').classList.remove('border-blue-300', 'text-blue-300');
        document.getElementById('one-liner-content').classList.remove('hidden');
        document.getElementById('three-liner-content').classList.add('hidden');
        document.getElementById('mnemonic-content').classList.add('hidden');
        document.getElementById('code-content').classList.add('hidden');
      });
      
      document.getElementById('three-liner-tab').addEventListener('click', () => {
        document.getElementById('three-liner-tab').classList.add('border-blue-300', 'text-blue-300');
        document.getElementById('one-liner-tab').classList.remove('border-blue-300', 'text-blue-300');
        document.getElementById('mnemonic-tab').classList.remove('border-blue-300', 'text-blue-300');
        document.getElementById('code-tab').classList.remove('border-blue-300', 'text-blue-300');
        document.getElementById('three-liner-content').classList.remove('hidden');
        document.getElementById('one-liner-content').classList.add('hidden');
        document.getElementById('mnemonic-content').classList.add('hidden');
        document.getElementById('code-content').classList.add('hidden');
      });
      
      document.getElementById('mnemonic-tab').addEventListener('click', () => {
        document.getElementById('mnemonic-tab').classList.add('border-blue-300', 'text-blue-300');
        document.getElementById('one-liner-tab').classList.remove('border-blue-300', 'text-blue-300');
        document.getElementById('three-liner-tab').classList.remove('border-blue-300', 'text-blue-300');
        document.getElementById('code-tab').classList.remove('border-blue-300', 'text-blue-300');
        document.getElementById('mnemonic-content').classList.remove('hidden');
        document.getElementById('one-liner-content').classList.add('hidden');
        document.getElementById('three-liner-content').classList.add('hidden');
        document.getElementById('code-content').classList.add('hidden');
      });
      
      document.getElementById('code-tab').addEventListener('click', () => {
        document.getElementById('code-tab').classList.add('border-blue-300', 'text-blue-300');
        document.getElementById('one-liner-tab').classList.remove('border-blue-300', 'text-blue-300');
        document.getElementById('three-liner-tab').classList.remove('border-blue-300', 'text-blue-300');
        document.getElementById('mnemonic-tab').classList.remove('border-blue-300', 'text-blue-300');
        document.getElementById('code-content').classList.remove('hidden');
        document.getElementById('one-liner-content').classList.add('hidden');
        document.getElementById('three-liner-content').classList.add('hidden');
        document.getElementById('mnemonic-content').classList.add('hidden');
      });
      
      // Card flipping
      flashcard.addEventListener('click', (e) => {
        // Don't flip when clicking tabs
        if (e.target.closest('button')) return;
        flashcard.classList.toggle('flipped');
      });

      // Initialize
      populateTopics();
    });
  </script>
</body>
</html>
